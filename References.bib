	%==================================================================================================
% LUKE PHD THESIS BIBTEX FILE
% ---------------------------
% Sorted chronologically
%==================================================================================================

@article{Hoare78,
   author      = {C. A. R. Hoare},
   title       = {Communicating sequential processes},
   journal     = {Communications of the ACM},
   volume      = {26},
   number      = {1},
   year        = {1983},
   issn        = {0001-0782},
   pages       = {100--106},
   doi         = {10.1145/357980.358021},
   publisher   = {ACM},
   address     = {New York, NY, USA},
   abstract    = {This paper suggests that input and output are basic primitives of programming 
and that parallel composition of communicating sequential processes is a fundamental program 
structuring method. When combined with a development of Dijkstra's guarded command, these concepts 
are surprisingly versatile. Their use is illustrated by sample solutions of a variety of familiar 
programming exercises.}
}


%SORTED AND FORMATTED TO HERE


@incollection {EC80,
   author          = {Emerson, E. and Clarke, Edmund},
   affiliation     = {Harvard University Aiken Computation Laboratory 02138 Cambridge Mass. USA 
02138 
   Cambridge Mass. USA},
   title           = {Characterizing correctness properties of parallel programs using fixpoints},
   booktitle       = {Automata, Languages and Programming},
   series          = {Lecture Notes in Computer Science},
   editor          = {de Bakker, Jaco and van Leeuwen, Jan},
   publisher       = {Springer Berlin / Heidelberg},
   isbn            = {},
   pages           = {169-181},
   volume          = {85},
   doi             = {10.1007/3-540-10003-2_69},
   year            = {1980},
   abstract        = {We have shown that correctness properties of parallel programs can be 
described using 
   computation trees and that from these descriptions fixpoint characterizations can be generated. 
We have 
   also given conditions on the form of computation tree descriptions to ensure that a correctness 
property 
   can be characterized using continuous fixpoints. A consequence is that a correctness property 
such as 
   inevitability under fair scheduling can be characterized as the least fixpoint of a monotonic, 
   noncontinuous transformer, but cannot be characterized using fixpoints of continuous 
transformers (nor as 
   the greatest fixpoint of a monotonic transformer of any degree of complexity lower than fair 
inevitability 
   itself). Hence, currently known proof rules are not applicable (see however [FS80]). We are now 
   investigating whether useful proof rules can exist for correctness properties having only a 
monotonic, 
   noncontinuous least fixpoint characterization. In addition, we are examining alternate notions 
of fairness 
   which do have continuous fixpoint characterizations.}
}

% BOOKS
%======
@book{BPMN2,
   author        = {Object Management Group},
   title         = {Business Process Model and Notation (BPMN) 2.0},
   publisher     = {Object Management Group},
   address       = {Needham MA, USA},
   url           = {http://www.omg.org/spec/BPMN/2.0/},
   year          = {2011}
}


% Unsorted
%=========
@unpublished{DDO07,
   title = {Formal Semantics and Analysis of BPMN Process Models},
   author = {Remco M. Dijkman and Marlon Dumas and Chun Ouyang},
   year = {2007},
   doi = {10.1.1.91.3621},
   url = {http://eprints.qut.edu.au/7115/},
   abstract = {The Business Process Modelling Notation (BPMN) is a standard for capturing business 
   processes in the early phases of system development. The mix of constructs in BPMN makes it 
   possible to define models with a range of semantic errors. But the static analysis of BPMN 
   models to detect such errors is hindered by ambiguities in the standard specification and the 
   complexity of the language. The fact that BPMN integrates constructs from graph-oriented 
   process definition languages with features for concurrent execution of multiple instances of a 
   subprocess and exception handling, makes it challenging to provide a formal semantics of BPMN. 
   Even more challenging is to provide a semantics that can be used to analyse BPMN models. This 
   paper proposes a formalisation of BPMN in terms a mapping to Petri nets, for which efficient 
   analysis techniques exist. The mapping has been implemented as a tool that generates code in 
   the Petri Net Markup Language. The formalisation has led to the identification of deficiencies 
   in the BPMN specification.}
}

@article{ODHA07,
   volume = {5},
   number = {1},
   author = {Chun Ouyang and Marlon Dumas and Arthur H. M. Ter Hofstede},
   title = {Pattern-based translation of BPMN process models to BPEL web services},
   publisher = {Idea Group Publishing},
   journal = {International Journal of Web Services Research (JWSR)},
   pages = {42--62},
   year = {2007},
   doi ={10.1.1.143.3118},
   url = {http://eprints.qut.edu.au/6810/},
   abstract = {The Business Process Modelling Notation (BPMN) is a graph-oriented language in
   which control and action nodes can be connected almost arbitrarily. It is primarily targeted at 
   domain analysts and is supported by many modelling tools, but in its current form, it lacks the 
   semantic precision required to capture fully executable business processes. The Business 
   Process Execution Language for Web Services (BPEL) on the other hand is a mainly 
   block-structured language, targeted at software developers and supported by several execution 
   platforms. In the current setting, translating BPMN models into BPEL code is a necessary step 
   towards standards-based business process development environments. This translation is 
   challenging since BPMN and BPEL represent two fundamentally different classes of languages. 
   Existing BPMN-to-BPEL translations rely on the identification of block-structured patterns in 
   BPMN models that are mapped into block-structured BPEL constructs. This paper advances the 
   state of the art in BPMN-to-BPEL translation by defining methods for identifying not only 
   perfectly block-structured fragments in BPMN models, but also quasi-structured fragments that 
   can be turned into perfectly structured ones and flow-based acyclic fragments that can be 
   mapped into a combination of block-structured constructs and control links. Beyond its direct 
   relevance in the context of BPMN and BPEL, this paper addresses issues that arise generally 
   when translating between graph-oriented and block-structured flow definition languages.}
}

@inproceedings{WG08,
   author = {Peter Y. Wong and Jeremy Gibbons},
   title = {A Process Semantics for BPMN},
   booktitle = {Proceedings of the 10th International Conference on Formal Methods and Software Engineering},
   series = {ICFEM '08},
   year = {2008},
   isbn = {978-3-540-88193-3},
   location = {Kitakyushu-City, Japan},
   pages = {355--374},
   numpages = {20},
   url = {http://dx.doi.org/10.1007/978-3-540-88194-0_22},
   doi = {http://dx.doi.org/10.1007/978-3-540-88194-0_22},
   acmid = {1483016},
   publisher = {Springer-Verlag},
   address = {Berlin, Heidelberg},
   abstract = {Business Process Modelling Notation (BPMN), developed by the Business Process 
   Management Initiative (BPMI), intends to bridge the gap between business process design and 
   implementation. However, the specification of the notation does not include a formal semantics. 
   This paper shows how a subset of the BPMN can be given a process semantics in Communicating 
   Sequential Processes. Such a semantics allows developers to formally analyse and compare BPMN 
   diagrams. A simple example of a business process is included to demonstrate the application of 
   the semantics; some theoretical results about the semantics are briefly discussed.}
} 

@article{KNP091,
   author = {Kwiatkowska, Marta and Norman, Gethin and Parker, David},
   title = {PRISM: probabilistic model checking for performance and reliability analysis},
   journal = {SIGMETRICS Perform. Eval. Rev.},
   volume = {36},
   issue = {4},
   month = {March},
   year = {2009},
   issn = {0163-5999},
   pages = {40--45},
   numpages = {6},
   url = {http://doi.acm.org/10.1145/1530873.1530882},
   doi = {http://doi.acm.org/10.1145/1530873.1530882},
   acmid = {1530882},
   publisher = {ACM},
   address = {New York, NY, USA},
   abstract = {Probabilistic model checking is a formal verification technique for the modelling 
   and analysis of stochastic systems. It has proved to be useful for studying a wide range of 
   quantitative properties of models taken from many diffierent application domains. This 
   includes, for example, performance and reliability properties of computer and communication 
   systems. In this paper, we give an overview of the probabilistic model checking tool PRISM, 
   focusing in particular on its support for continuous-time Markov chains and Markov reward 
   models, and how these can be used to analyse performability properties.}
} 

@inproceedings{KNP11,
   author={M. Kwiatkowska and G. Norman and D. Parker},
   title={{PRISM} 4.0: Verification of Probabilistic Real-time Systems},
   booktitle={Proc. 23rd International Conference on Computer Aided Verification (CAV'11)},
   year={2011},   
   editor={G. Gopalakrishnan and S. Qadeer},
   pages={585--591},
   organization={},
   publisher={Springer},
   series={LNCS},
   volume={6806},
   address={},
   month={},
   note={},
   key={}
}



@incollection{test00,
   author          = {Clarke, Edmund and Grumberg, Orna and Jha, Somesh and Lu, Yuan and Veith, Helmut},
   affiliation     = {Carnegie Mellon University, Pittsburgh USA USA},
   title           = {Counterexample-Guided Abstraction Refinement},
   booktitle       = {Computer Aided Verification},
   series          = {Lecture Notes in Computer Science},
   editor          = {Emerson, E. and Sistla, A.},
   publisher       = {Springer Berlin / Heidelberg},
   isbn            = {},
   pages           = {154-169},
   volume          = {1855},
   doi             = {10.1007/10722167_15},
   year            = {2000},
   abstract        = {We present an automatic iterative abstraction-refinement methodology in which the 
initial abstract model is generated by an automatic analysis of the control structures in the program to be 
verified. Abstract models may admit erroneous (or  spurious ) counterexamples. We devise new symbolic 
techniques which analyze such counterexamples and refine the abstract model correspondingly. The refinement 
algorithm keeps the size of the abstract state space small due to the use of abstraction functions which 
distinguish many degrees of abstraction for each program variable. We describe an implementation of our 
methodology in NuSMV. Practical experiments including a large Fujitsu IP core design with about 500 latches 
and 10000 lines of SMV code confirm the effectiveness of our approach.}   
}

@incollection{MPQV05,
   author          = {Mardare, Radu and Priami, Corrado and Quaglia, Paola and Vagin, Oleksandr},
   affiliation     = {Dipartimento di Informatica e Telecomunicazioni, Università di Trento Italy},
   title           = {Model Checking Biological Systems Described Using Ambient Calculus},
   booktitle       = {Computational Methods in Systems Biology},
   series          = {Lecture Notes in Computer Science},
   editor          = {Danos, Vincent and Schachter, Vincent},
   publisher       = {Springer Berlin / Heidelberg},
   isbn            = {},
   pages           = {85-103},
   volume          = {3082},
   doi             = {10.1007/978-3-540-25974-9_8},
   year            = {2005},
   abstract        = {We propose a way of performing model checking analysis for biological systems. The 
techniques were developed for a CTL* logic built upon Ambient Calculus.We introduce labelled syntax trees 
for ambient processes and use them as possible worlds in a Kripke structure developed for a propositional 
branching temporal logic. The accessibility relation over labelled syntax trees is generated by the 
reduction over corresponding Ambient Calculus processes.Providing the algorithms for calculating the 
accessibility relation between states, we open the perspective of using model checking algorithms developed 
for temporal logics in analysing any phenomena described in Ambient Calculus.}   
}

@inproceedings{FFK05,
   author          = {Fisteus, Jes\'{u}s Arias and Fern\'{a}ndez, Luis S\'{a}nchez and Kloos, Carlos Delgado},
   title           = {Applying model checking to BPEL4WS business collaborations},
   booktitle       = {SAC '05: Proceedings of the 2005 ACM symposium on Applied computing},
   year            = {2005},
   isbn            = {1-58113-964-0},
   pages           = {826--830},
   location        = {Santa Fe, New Mexico},
   doi             = {10.1145/1066677.1066866},
   publisher       = {ACM},
   address         = {New York, NY, USA},
   abstract        = {Web services are a very appropriate communication mechanism to perform distributed 
business processes among several organisations. These processes should be reliable, because a failure in 
them can cause high economic losses. In this work we propose a framework for the verification of business 
processes, called VERBUS. Its aim is to help the designer to find errors in specifications at design time, 
thus increasing their reliability. Contrary to verification frameworks previously proposed for business 
processes, VERBUS is a modular an extensible framework, in the sense that it is not tied to specific 
process definition languages or verification tools. This is achieved with the definition of an intermediate 
formalism that disconnects definition languages from verification tools. In this paper we present VERBUS, 
and its prototype, that integrates the BPEL4WS definition language and the Spin and SMV verification tools.}
}

@article{KNP09,
   author          = {Kwiatkowska, Marta and Norman, Gethin and Parker, David},
   title           = {PRISM: probabilistic model checking for performance and reliability analysis},
   journal         = {SIGMETRICS Perform. Eval. Rev.},
   volume          = {36},
   number          = {4},
   year            = {2009},
   issn            = {0163-5999},
   pages           = {40--45},
   doi             = {10.1145/1530873.1530882},
   publisher       = {ACM},
   address         = {New York, NY, USA},
   abstract        = {Probabilistic model checking is a formal verification technique for the modelling and 
analysis of stochastic systems. It has proved to be useful for studying a wide range of quantitative 
properties of models taken from many different application domains. This includes, for example, performance 
and reliability properties of computer and communication systems. In this paper, we give an overview of the 
probabilistic model checking tool PRISM, focusing in particular on its support for continuous-time Markov 
chains and Markov reward models, and how these can be used to analyse performability properties.}
}

% BOOKS (sorted chronologically)
%===============================
@book{McMillan93,
   author        = {McMillan, Kenneth L.},
   title         = {Symbolic Model Checking},
   isbn          = {0792393805},
   publisher     = {Kluwer Academic Publishers},
   address       = {Norwell, MA, USA},
   url           = {http://portal.acm.org/citation.cfm?id=530225},
   year          = {1993},
   abstract      = {Formal verification means having a mathematical model of a system, a language for 
specifying desired properties of the system in a concise, comprehensible and unambiguous way, and a method 
of proof to verify that the specified properties are satisfied. When the method of proof is carried out 
substantially by machine, we speak of automatic verification. Symbolic Model Checking deals with methods of 
automatic verification as applied to computer hardware.
   The practical motivation for study in this area is the high and increasing cost of correcting design errors 
in VLSI technologies. There is a growing demand for design methodologies that can yield correct designs on 
the first fabrication run. Moreover, design errors that are discovered before fabrication can also be quite 
costly, in terms of engineering effort required to correct the error, and the resulting impact on 
development schedules. Aside from pure cost considerations, there is also a need on the theoretical side to 
provide a sound mathematical basis for the design of computer systems, especially in areas that have 
received little theoretical attention.}
}